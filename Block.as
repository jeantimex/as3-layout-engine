package {		import com.greensock.TweenLite;		import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.filters.BitmapFilterQuality;	import flash.filters.DropShadowFilter;	import flash.geom.Point;
		public class Block extends MovieClip {				/**		 * Used to drag the block		 */		public var header:MovieClip;				/**		 * Used to change the size of the block		 */		public var dragger:MovieClip;				public var background:MovieClip;		public var border:MovieClip;				public var id:String;				private var _container:Grid;		public function get container():Grid {			return _container;		}		public function set container( value:Grid ): void {			_container = value;						// Save the container width and height			containerW = container.width;			containerH = container.height;						cells = getCellsIndices();		}				private var containerW:Number;		private var containerH:Number;				private var offsetX:Number;		private var offsetY:Number;				private var currentX:Number;		private var currentY:Number;				private var currentW:Number;		private var currentH:Number;				private var minW:Number = 50;		private var minH:Number = 50;				private var status:Number;				public var w:Number;		public var h:Number;				/**		 * Record the cells it covers		 */		public var cells:Array;				/**		 * Constructor		 */		public function Block() {					}				/**		 * 		 */		public function init( option:Object ): void {			// Configure the block			x = option.hasOwnProperty( "x" ) ? option.x : 0;			y = option.hasOwnProperty( "y" ) ? option.y : 0;			w = option.hasOwnProperty( "w" ) ? option.w : 0;			h = option.hasOwnProperty( "h" ) ? option.h : 0;						resize( w, h );						// Enable header and dragger button mode			header.buttonMode = true;			dragger.buttonMode = true;						// Listen to header mouse down event			header.addEventListener( MouseEvent.MOUSE_DOWN, onHeaderMouseDownHandler );						// Listen to dragger mouse down event			dragger.addEventListener( MouseEvent.MOUSE_DOWN, onDraggerMouseDownHandler );						// Listen to background mouse down event			background.addEventListener( MouseEvent.MOUSE_DOWN, onBackgroundMouseDownHandler );		}				/**		 * 		 */		private function onHeaderMouseDownHandler( e:MouseEvent ):void {			// Set status to drag & drop			status = 0;						// Record the mouse position			offsetX = mouseX;			offsetY = mouseY;						// Save the current position for later use			currentX = x;			currentY = y;						putOnTop();			dropShadow();						// Then listen to stage events			listenToStageEvents();						container.lightOn( getCellsIndices() );						//trace( "cells: " + cells );		}				/**		 * 		 */		private function onDraggerMouseDownHandler( e:MouseEvent ): void {			// Set status to resize			status = 1;						// Record the mouse position			offsetX = stage.mouseX;			offsetY = stage.mouseY;						// Record the current width and height			currentW = background.width;			currentH = background.height;						putOnTop();			dropShadow();						listenToStageEvents();			container.lightOn( getCellsIndices( true ) );						//trace( "cells: " + cells );		}				/**		 * 		 */		private function onBackgroundMouseDownHandler( e:MouseEvent ): void {			putOnTop();		}				/**		 * 		 */		private function listenToStageEvents(): void {			stage.addEventListener( MouseEvent.MOUSE_MOVE, onStageMouseMoveHandler );			stage.addEventListener( MouseEvent.MOUSE_UP, onStageMouseUpHandler );		}				/**		 * 		 */		private function onStageMouseMoveHandler( e:MouseEvent ): void {			switch ( status ) {				// Drag & Drop				case 0:					var px:Number = container.mouseX - offsetX;					var py:Number = container.mouseY - offsetY;										move( px, py );										container.lightOn( getCellsIndices() );										break;								// Resize				case 1:					var pw:Number = currentW + stage.mouseX - offsetX;					var ph:Number = currentH + stage.mouseY - offsetY;										resize( pw, ph );										container.lightOn( getCellsIndices( true ) );										break;			}						e.updateAfterEvent();		}				/**		 * 		 */		private function onStageMouseUpHandler( e:MouseEvent ): void {			// Remove stage event listeners			stage.removeEventListener( MouseEvent.MOUSE_MOVE, onStageMouseMoveHandler );			stage.removeEventListener( MouseEvent.MOUSE_UP, onStageMouseUpHandler );						// Drop it			switch ( status ) {				case 0:					dropIt();					break;				case 1:					sizeIt();					break;			} 						// Reset the status			status = -1;						removeShadow();						container.lightOff();		}				/**		 * 		 */		private function putOnTop(): void {			container.setChildIndex( this, container.numChildren - 1 );		}				/**		 * Drop shadow on background		 */		private function dropShadow(): void {			this.alpha = 0.8;			background.filters = [ new DropShadowFilter(5, 45, 0x999999, BitmapFilterQuality.HIGH, 5, 5, 1) ];		}				/**		 * Remove the shadow filter		 */		private function removeShadow(): void {			this.alpha = 1;			background.filters = [];		}				/**		 * 		 */		private function restrictPosition( px:Number, py:Number ):Object {			px = px < 0 ? 0 : px;			py = py < 0 ? 0 : py;			px = (px + background.width) > containerW ? (containerW - background.width) : px;			py = (py + background.height) > containerH ? (containerH - background.height) : py;						return { x:px, y:py };		}				/**		 * 		 */		private function restrictSize( pw:Number, ph:Number ):Object {			pw = ( x + pw ) > containerW ? ( containerW - x ) : pw;			ph = ( y + ph ) > containerH ? ( containerH - y ) : ph;						pw = pw < minW ? minW : pw;			ph = ph < minH ? minH : ph;						return { w:pw, h:ph };		}				/**		 * 		 */		private function dropIt(): void {			// Get hightlighted cells info			var info:Object = container.getCellsInfo( getCellsIndices() );			// Move block			move( info.x, info.y, true );		}				/**		 * 		 */		private function sizeIt(): void {			// Get hightlighted cells info			var info:Object = container.getCellsInfo( getCellsIndices( true ) );			// Resize the block			resize( info.w, info.h, true );		}				/**		 * Move the block		 */		private function move( px:Number, py:Number, animate:Boolean = false ): void {			var p:Object = restrictPosition(px, py);						var time:Number = animate ? 0.1 : 0;						TweenLite.to( this, time, { x:p.x, y:p.y, onComplete:updateCells } );		}				/**		 * Resize the block		 */		private function resize( pw:Number, ph:Number, animate:Boolean = false ): void {			var s:Object = restrictSize( pw, ph );						w = s.w;			h = s.h;						var time:Number = animate ? 0.1 : 0;			TweenLite.to( background, time, { width:s.w, height:s.h, onComplete:updateCells } );			TweenLite.to( header, time, { width:s.w } );			TweenLite.to( border, time, { width:s.w, height:s.h } );			TweenLite.to( dragger, time, { x:s.w - dragger.width, y:s.h - dragger.height, onComplete:updateCells } );					}				public function getCellsIndices( isDragging:Boolean = false ): Array {			return container.getCellsIndices( this, isDragging );		}				private function updateCells(): void {			cells = getCellsIndices();		}	}	}
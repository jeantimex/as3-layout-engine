package com.jeantimex.as3.layout {		import com.greensock.TweenLite;		import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.filters.BitmapFilterQuality;	import flash.filters.DropShadowFilter;	import flash.geom.Point;
		/**	 * A block is a display object that is put into the cells area	 * Normally the size of the block is equal to the size of the cells area	 * 	 * @author Yong Su	 * @date 09/30/2012	 */	public class Block extends MovieClip {				/**		 * Used to move the block		 */		public var header:MovieClip;				/**		 * Used to change the size of the block		 */		public var dragger:MovieClip;				/**		 * The background panel		 */		public var background:MovieClip;				/**		 * The border		 */		public var border:MovieClip;				/**		 * ID should be unique for querying purpose		 */		public var id:String;				/**		 * Its parent grid container		 */		private var _container:Grid;		public function get container():Grid {			return _container;		}		public function set container( value:Grid ): void {			_container = value;						// Save the container width and height			containerW = container.width;			containerH = container.height;						// Initialize the cells it covers			cells = getCellsIndices();		}				/**		 * Container width		 */		private var containerW:Number;				/**		 * Container height		 */		private var containerH:Number;				/**		 * Record the mouse offset when pressing on the header and dragger		 */		private var offsetX:Number;		private var offsetY:Number;				/**		 * The current position		 */		private var currentX:Number;		private var currentY:Number;				/**		 * The current dimension		 */		private var currentW:Number;		private var currentH:Number;				/**		 * The minimum size of the block		 * Default 50 pixels for both width and height		 */		private var minW:Number = 50;		private var minH:Number = 50;				/**		 * Status		 * 0: moving (drag and drop)		 * 1: resizing		 */		private var status:Number;				/**		 * Block width (read only)		 */		public var w:Number;				/**		 * Block height (read only)		 */		public var h:Number;				/**		 * Record the cells it covers		 */		public var cells:Array;				/**		 * Constructor		 */		public function Block() {			// Enable header and dragger button mode			header.buttonMode = true;			dragger.buttonMode = true;						// Listen to header mouse down event			header.addEventListener( MouseEvent.MOUSE_DOWN, onHeaderMouseDownHandler );						// Listen to dragger mouse down event			dragger.addEventListener( MouseEvent.MOUSE_DOWN, onDraggerMouseDownHandler );						// Listen to background mouse down event			background.addEventListener( MouseEvent.MOUSE_DOWN, onBackgroundMouseDownHandler );		}				/**		 * Initialize with object that contains supported parameters		 */		public function init( option:Object ): void {			// Configure the block			x = option.hasOwnProperty( "x" ) ? option.x : 0;			y = option.hasOwnProperty( "y" ) ? option.y : 0;			w = option.hasOwnProperty( "w" ) ? option.w : 0;			h = option.hasOwnProperty( "h" ) ? option.h : 0;						// Resize it			resize( w, h );		}				/**		 * Event handler when mouse click on the header		 */		private function onHeaderMouseDownHandler( e:MouseEvent ):void {			// Set status to drag & drop			status = 0;						// Record the mouse position			offsetX = mouseX;			offsetY = mouseY;						// Save the current position for later use			currentX = x;			currentY = y;						/**			 * Put it on top and display a shadow			 */			putOnTop();			dropShadow();						// Then listen to stage events			listenToStageEvents();						container.lightOn( getCellsIndices() );						//trace( "cells: " + cells );		}				/**		 * Event handler when mouse click on the dragger		 */		private function onDraggerMouseDownHandler( e:MouseEvent ): void {			// Set status to resize			status = 1;						// Record the mouse position			offsetX = stage.mouseX;			offsetY = stage.mouseY;						// Record the current width and height			currentW = background.width;			currentH = background.height;						/**			 * Put it on top and display a shadow			 */			putOnTop();			dropShadow();						listenToStageEvents();			container.lightOn( getCellsIndices( true ) );						//trace( "cells: " + cells );		}				/**		 * Event handler when mouse click on the background		 */		private function onBackgroundMouseDownHandler( e:MouseEvent ): void {			// Simply put it on top			putOnTop();		}				/**		 * Better use stage events to handle drag and drop		 */		private function listenToStageEvents(): void {			stage.addEventListener( MouseEvent.MOUSE_MOVE, onStageMouseMoveHandler );			stage.addEventListener( MouseEvent.MOUSE_UP, onStageMouseUpHandler );		}				/**		 * Event handler when mouse moving on the stage		 */		private function onStageMouseMoveHandler( e:MouseEvent ): void {			switch ( status ) {				// Drag & Drop				case 0:					// Get the block upper left corner position					var px:Number = container.mouseX - offsetX;					var py:Number = container.mouseY - offsetY;										// Move the block					move( px, py );										// Highlight the areas that it covers					container.lightOn( getCellsIndices() );										break;								// Resize				case 1:					// Get the block size that is controlled by the mouse					var pw:Number = currentW + stage.mouseX - offsetX;					var ph:Number = currentH + stage.mouseY - offsetY;										// Resize it					resize( pw, ph );										// Hightlight the available areas					container.lightOn( getCellsIndices( true ) );										break;			}						e.updateAfterEvent();		}				/**		 * Event handler when mouse is release from the stage		 */		private function onStageMouseUpHandler( e:MouseEvent ): void {			// Remove stage event listeners			stage.removeEventListener( MouseEvent.MOUSE_MOVE, onStageMouseMoveHandler );			stage.removeEventListener( MouseEvent.MOUSE_UP, onStageMouseUpHandler );						switch ( status ) {				case 0:					dropIt();					break;				case 1:					sizeIt();					break;			} 						// Reset the status			status = -1;						removeShadow();						container.lightOff();		}				/**		 * Put the block on top of the container		 */		private function putOnTop(): void {			container.setChildIndex( this, container.numChildren - 1 );		}				/**		 * Drop shadow on background		 */		private function dropShadow(): void {			alpha = 0.8;			background.filters = [ new DropShadowFilter(5, 45, 0x999999, BitmapFilterQuality.HIGH, 5, 5, 1) ];		}				/**		 * Remove the shadow filter		 */		private function removeShadow(): void {			this.alpha = 1;			background.filters = [];		}				/**		 * Restrict the block position within the container area		 */		private function restrictPosition( px:Number, py:Number ):Object {			px = px < 0 ? 0 : px;			py = py < 0 ? 0 : py;			px = (px + background.width) > containerW ? (containerW - background.width) : px;			py = (py + background.height) > containerH ? (containerH - background.height) : py;						return { x:px, y:py };		}				/**		 * Restrict the block size within the container area		 */		private function restrictSize( pw:Number, ph:Number ):Object {			pw = ( x + pw ) > containerW ? ( containerW - x ) : pw;			ph = ( y + ph ) > containerH ? ( containerH - y ) : ph;						pw = pw < minW ? minW : pw;			ph = ph < minH ? minH : ph;						return { w:pw, h:ph };		}				/**		 * Drop the block		 * This function called in the stage mouse up event handler		 */		private function dropIt(): void {			// Get hightlighted cells info			var info:Object = container.getCellsInfo( getCellsIndices() );			// Move block			move( info.x, info.y, true );		}				/**		 * Resize the block		 * This function is called in the stage mouse up event handler		 */		private function sizeIt(): void {			// Get hightlighted cells info			var info:Object = container.getCellsInfo( getCellsIndices( true ) );			// Resize the block			resize( info.w, info.h, true );		}				/**		 * Move the block		 */		private function move( px:Number, py:Number, animate:Boolean = false ): void {			var p:Object = restrictPosition(px, py);						var time:Number = animate ? 0.1 : 0;			TweenLite.to( this, time, { x:p.x, y:p.y, onComplete:updateCells } );		}				/**		 * Resize the block		 */		private function resize( pw:Number, ph:Number, animate:Boolean = false ): void {			var s:Object = restrictSize( pw, ph );						w = s.w;			h = s.h;						var time:Number = animate ? 0.1 : 0;			TweenLite.to( background, time, { width:s.w, height:s.h, onComplete:updateCells } );			TweenLite.to( header, time, { width:s.w } );			TweenLite.to( border, time, { width:s.w, height:s.h } );			TweenLite.to( dragger, time, { x:s.w - dragger.width, y:s.h - dragger.height, onComplete:updateCells } );					}				/**		 * Get the cell indices that are covered by a block		 */		public function getCellsIndices( isDragging:Boolean = false ): Array {			return container.getCellsIndices( this, isDragging );		}				/**		 * Get the cells indices it covers		 */		private function updateCells(): void {			cells = getCellsIndices();		}	}}